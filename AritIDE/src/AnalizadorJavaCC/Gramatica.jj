
options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(Gramatica)
/** Analizador de lenguaje Arit **/

//imports

public class Gramatica{

}
PARSER_END(Gramatica)


/* Análisis léxico*/

SKIP : {
    " "
    | "\t"
    | "\r"
    | "\n"
    | <"#" (~["\n", "\r"])*>
    | <"#*" (~["*"])* "*" ("*" | ~["*","#"] (~["*"])* "*")* "#">
}

TOKEN : {

  <NUMERO: (["0"-"9"])+>
  | <DECIMAL: (["0"-"9"])+"."(["0"-"9"])+>
  | <CADENA: "\""((~["\"","\n"]|~(\\,"\"")))"\"">
  | <RNULL: "null">
  | <RIF: "if">
  | <RELSE: "else">
  | <RPRINT: "print">
  | <RSWITCH: "switch">
  | <RCASE: "case">
  | <RWHILE: "while">
  | <RDO: "do">
  | <RFOR: "for">
  | <RIN: "in">
  | <RBREAK: "break">
  | <RCONTINUE: "continue">
  | <RRETURN: "return">
  | <RFUNC: "function">
  | <RC: "c">
  | <RTYPEOF: "typeof">
  | <RLENGTH: "length">
  | <RNCOL: "ncol">
  | <RNROW: "nrow">
  | <RSTRINGLENGTH: "stringlength">
  | <RREMOVE: "remove">
  | <RTOLOWER: "tolowercase">
  | <RTOUPPER: "touppercase">
  | <RTRUNK: "trunk">
  | <RROUND: "round">
  | <RMEAN: "mean">
  | <RMEDIAN: "median">
  | <RMODE: "mode">
  | <RLIST: "list">
  | <RMATRIX: "matrix">
  | <RARRAY: "array">
  | <RPIE: "pie">
  | <RBARPLOT: "barplot">
  | <RPLOT: "plot">
  | <RHIST: "hist">

  | <PTCOMA: ";">
  | <COMA: ",">
  | <DOSPT: ":">
  | <PARIZQ: "(">
  | <PARDER: ")">
  | <CORIZQ: "[">
  | <CORDER: "]">
  | <LLAVEIZQ: "{">
  | <LLAVEDER: "}">
  | <MAS: "+">
  | <MENOS: "-">
  | <POR: "*">
  | <DIV: "/">
  | <POT: "^">
  | <MOD: "%%">
  | <TERNARIO: "?">
  | <IGUAL: "=">
  | <MENQUE: "<">
  | <MAYQUE: ">">
  | <MENIGUAL: "<=">
  | <MAYIGUAL: ">=">
  | <IGUALACION: "==">
  | <DIFERENCIACION: "!=">
  | <AND: "&">
  | <OR: "|">
  | <NOT: "!" >
  | <IGUALFUNC: "=>">
  | <IDENTIFICADOR: ["."]? ["a"-"z","A"-"Z", "_"] ( ["a"-"z","A"-"Z", "_","."] | ["0"-"9"] )* >
}


MORE :
{
    "\"" :STRING_STATE
}

<STRING_STATE> MORE:
{
    <~["\""]>
}

<STRING_STATE> TOKEN:
{
   <STRING:"\""> : DEFAULT 
}
/** Fin Lexico */


/**
 * Producción inicial
 * Analizar -> (Instruccion)+ EOF
 */
AST Analizar():
{LinkedList<NodoAST> ins = new LinkedList<>(); NodoAST nodo;}
{
  (nodo = Instruccion() {ins.add(nodo);})+ <EOF> {return new AST(ins);}
}

/**
 * Instrucción -> print
 *              | declaracion
 *              | asignación
 *              | if 
 *              | while
 *              | switch
 *              | do while
 *              | for
 *              | llamada
 *              | length 
 *              | ncol
 *              | nrow 
 *              | stringlength
 *              | remove 
 *              | tolower
 *              | toupper
 *              | trunk
 *              | round
 *              | mean
 *              | median
 *              | mode
 *              
 */
NodoAST Instruccion() :
{NodoAST nodo;}
{
  nodo = Print() {return nodo;}
  |
  nodo = Asignacion() {return nodo;}
  |
  nodo = If() {return nodo;}
}

/**
 * RPRINT -> print ( Expresion );
 */
NodoAST Print() : 
{NodoAST nodo;}
{
  <RPRINT> <PARIZQ> nodo = Expresion() <PARDER> <PTCOMA> 
}

/**
 * Asignación-> IDENTIFICADOR = expresion;
 *            | IDENTIFICADOR Dimension = expresion;
 */
NodoAST Asignacion() :
{NodoAST nodo;Token id;}
{
  id=<IDENTIFICADOR><IGUAL> nodo = Expresion() <PTCOMA> {return new Asignacion();}
}

/**
 * If -> if(condicion) { Bloque } (else if {Bloque})* (else {bloque})?
 */
NodoAST If() :
{NodoAST nodo, if; LinkedList<NodoAST> insIf, insElse = LinkedList<NodoAST>(); }
{
  <RIF> <PARIZQ> nodo = Expresion() <PARDER> insIf = Bloque()
  (
    LOOKAHEAD(2) <RELSE> if = If() {insElse.add(if);}
    |
    LOOKAHEAD(2) <RELSE> insElse = Bloque()
  )?
  {return new If(nodo, insIf,insElse,token.beginLine,token.beginColumn);}
}

/**
 * Bloque -> {instrucciones+}
 */
LinkedList<NodoAST> Bloque() : 
{LinkedList<NodoAST> insBloque = new LinkedList<>(NodoAST); NodoAST nodo;}
{
  <LLAVEIZQ> (nodo=Instruccion() {insBloque.add(nodo);})* <LLAVEDER>{return insBloque;}
}

/**
 * Expresion
 */
NodoAST Expresion():
{NodoAST e,e1;}
{
  e = CondicionAnd()
  (
    <AND> e1=CondicionAnd() {e = new Logica(e,e1,OperadorLogico.AND,token.beginLine,token.beginColumn);}
    |
    <OR> e1 = CondicionAnd() {e = new Logica(e,e1,OperadorLogico.OR,token.beginLine,token.beginColumn);}
  )*
  {return e;}
}

NodoAST CondicionAnd():
{NodoAST e,e1;}
{
  
}

NodoAST Primitivo():
{NodoAST e; Token t;}
{
  <NUMERO>{return new Primitivo();}
  |
  <DECIMAL>{return new Primitivo();}
  |
  t = <STRING> {return new Primitivo();}
  |<PARIZQ> e = Expresion() <PARDER> {return e;}
}
